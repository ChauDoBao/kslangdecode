<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>K-Slang Decoder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles to complement Tailwind */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #FEF7F9; /* Soft pastel pink */
        }

        /* Custom gradient for the logo */
        .logo-gradient {
            background: linear-gradient(90deg, #f9a8d4, #a5b4fc);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 2px 2px 8px rgba(244, 114, 182, 0.2);
        }

        /* Styling for active tab */
        .tab-btn.active {
            background-color: #f472b6; /* Brighter pink for active state */
            color: white;
            font-weight: 600;
        }

        /* Custom scrollbar for chat */
        .chat-box::-webkit-scrollbar {
            width: 8px;
        }
        .chat-box::-webkit-scrollbar-track {
            background: #fde6f1;
        }
        .chat-box::-webkit-scrollbar-thumb {
            background-color: #f9a8d4;
            border-radius: 20px;
            border: 3px solid #fde6f1;
        }

        /* Simple loading spinner */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #f9a8d4;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Hide spinner by default */
        .hidden-loader {
            display: none;
        }

        /* Styles for the new sentence structure boxes and rendered markdown */
        #explanationResult h3, #dailyFeed h3 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            border-bottom: 2px solid #fbcfe8;
            padding-bottom: 0.25rem;
        }
         #dailyFeed h1, #dailyFeed h2 {
            font-size: 1.5rem;
            font-weight: 700;
        }
        #explanationResult ul, #dailyFeed ul {
            list-style-position: inside;
            padding-left: 0.5rem;
        }
         #explanationResult li, #dailyFeed li {
            margin-bottom: 0.25rem;
        }
        
        /* Styles for Image OCR Modal */
        #imagePreviewContainer {
            position: relative;
            max-width: 100%;
            max-height: 70vh;
            overflow: auto;
        }
        #resizableBox {
            position: absolute;
            border: 2px solid #f472b6;
            cursor: move;
            background-color: rgba(244, 114, 182, 0.2);
        }
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #f472b6;
            border: 1px solid white;
            border-radius: 50%;
        }
        .resize-handle.nw { top: -5px; left: -5px; cursor: nwse-resize; }
        .resize-handle.ne { top: -5px; right: -5px; cursor: nesw-resize; }
        .resize-handle.sw { bottom: -5px; left: -5px; cursor: nesw-resize; }
        .resize-handle.se { bottom: -5px; right: -5px; cursor: nwse-resize; }
    </style>
</head>
<body class="text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-4xl">
        <header class="flex items-center mb-6">
            <div class="text-3xl md:text-4xl font-bold logo-gradient">
                K-Slang Decoder
            </div>
        </header>

        <main class="bg-white rounded-2xl shadow-lg p-6 md:p-8">
            <nav class="flex flex-wrap border-b border-gray-200 mb-6">
                <button onclick="showTab('decoder')" class="tab-btn active text-sm md:text-base py-2 px-4 rounded-t-lg -mb-px hover:bg-pink-100 transition">Decoder</button>
                <button onclick="showTab('translator')" class="tab-btn text-sm md:text-base py-2 px-4 rounded-t-lg -mb-px hover:bg-pink-100 transition">Translator</button>
                <button onclick="showTab('community')" class="tab-btn text-sm md:text-base py-2 px-4 rounded-t-lg -mb-px hover:bg-pink-100 transition">Community Bank</button>
                <button onclick="showTab('quiz')" class="tab-btn text-sm md:text-base py-2 px-4 rounded-t-lg -mb-px hover:bg-pink-100 transition">Quiz</button>
                <button onclick="showTab('feed')" class="tab-btn text-sm md:text-base py-2 px-4 rounded-t-lg -mb-px hover:bg-pink-100 transition">Daily Feed</button>
                <button onclick="showTab('chatbot')" class="tab-btn text-sm md:text-base py-2 px-4 rounded-t-lg -mb-px hover:bg-pink-100 transition">Roleplay Chat</button>
            </nav>

            <div>
                <div id="decoderTab" class="tab-content">
                    <p class="mb-4 text-gray-600">Paste a Korean phrase, or upload an image of one. Our AI will break it down, explain the slang, and teach you the context!</p>
                    <div class="flex items-start w-full p-3 border border-gray-200 rounded-xl bg-white focus-within:ring-2 focus-within:ring-pink-300 focus-within:border-pink-300 transition">
                        <span class="text-2xl mr-3 pt-1">🇰🇷</span>
                        <textarea id="koreanInput" rows="4" class="w-full h-full resize-none border-none focus:ring-0 bg-transparent placeholder-gray-400" placeholder="예: 이 노래 완전 찢었다 ㅋㅋ"></textarea>
                    </div>
                    <input id="extraContext" class="w-full mt-2 p-3 border border-gray-200 rounded-xl focus:ring-2 focus:ring-pink-300 focus:border-pink-300 transition" placeholder="Add extra context (e.g., from a K-Drama, a tweet)...">
                    <div class="flex items-center mt-4 space-x-4">
                        <button onclick="analyzePhrase()" class="px-6 py-3 bg-pink-400 text-white font-semibold rounded-full hover:bg-pink-500 transition shadow-md">Decode Phrase</button>
                        <label for="imageUpload" class="cursor-pointer px-6 py-3 bg-indigo-400 text-white font-semibold rounded-full hover:bg-indigo-500 transition shadow-md">
                            Upload Image
                        </label>
                        <input type="file" id="imageUpload" class="hidden" accept="image/*" onchange="handleImageUpload(event)">
                        <button id="voiceInputBtn" onclick="startVoiceRecognition()" class="p-3 bg-teal-400 text-white font-semibold rounded-full hover:bg-teal-500 transition shadow-md">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" /></svg>
                        </button>
                    </div>
                    <p id="ocrStatus" class="mt-4 text-gray-600"></p>
                    <div id="decoderLoader" class="loader hidden-loader"></div>
                    <div id="listenBtnContainer" class="mt-6"></div>
                    <div id="structureResult" class="mt-2 flex flex-wrap gap-3"></div>
                    <div id="explanationResult" class="mt-4 p-4 bg-pink-50 rounded-xl"></div>
                </div>

                <div id="translatorTab" class="tab-content" style="display:none;">
                    <p class="mb-4 text-gray-600">Translate from English, Vietnamese, or Chinese to natural-sounding Korean, based on the context you provide.</p>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div>
                            <label for="sourceLang" class="block text-sm font-medium text-gray-700 mb-1">Translate from:</label>
                            <select id="sourceLang" class="w-full p-3 border border-gray-200 rounded-xl focus:ring-2 focus:ring-pink-300 focus:border-pink-300 transition">
                                <option value="English">English</option>
                                <option value="Vietnamese">Vietnamese</option>
                                <option value="Chinese">Chinese</option>
                            </select>
                        </div>
                        <div>
                            <label for="translationContext" class="block text-sm font-medium text-gray-700 mb-1">Context:</label>
                             <input id="translationContext" class="w-full p-3 border border-gray-200 rounded-xl focus:ring-2 focus:ring-pink-300 focus:border-pink-300 transition" placeholder="e.g., Talking to a friend, formal email...">
                        </div>
                    </div>
                    <textarea id="sourceText" rows="4" class="w-full p-3 border border-gray-200 rounded-xl focus:ring-2 focus:ring-pink-300 focus:border-pink-300 transition" placeholder="Enter text to translate..."></textarea>
                    <button onclick="translateToKorean()" class="mt-4 px-6 py-3 bg-pink-400 text-white font-semibold rounded-full hover:bg-pink-500 transition shadow-md">Translate</button>
                    <div id="translatorLoader" class="loader hidden-loader"></div>
                    <div class="mt-6 p-4 bg-pink-50 rounded-xl">
                        <div id="translationResult" class="text-xl font-semibold text-gray-800"></div>
                        <div id="translationListenBtnContainer" class="mt-2"></div>
                    </div>
                </div>

                <div id="communityTab" class="tab-content" style="display:none;">
                    <p class="mb-4 text-gray-600">Found a confusing or funny phrase? Share it with the community! Vote on submissions to help everyone learn.</p>
                     <div class="mb-4">
                        <textarea id="submissionText" rows="3" class="w-full p-3 border border-gray-200 rounded-xl" placeholder="Share a new phrase..."></textarea>
                        <button onclick="submitPhrase()" class="mt-2 px-6 py-3 bg-pink-400 text-white font-semibold rounded-full hover:bg-pink-500 transition shadow-md">Submit</button>
                    </div>
                    <div id="communityLoader" class="loader hidden-loader"></div>
                    <div id="communityFeed" class="space-y-4"></div>
                </div>

                <div id="quizTab" class="tab-content" style="display:none;">
                     <p class="mb-4 text-gray-600">Test your knowledge with quizzes generated from real-world phrases submitted by the community.</p>
                    <button onclick="generateQuiz()" class="px-6 py-3 bg-pink-400 text-white font-semibold rounded-full hover:bg-pink-500 transition shadow-md">Generate New Quiz</button>
                    <div id="quizLoader" class="loader hidden-loader"></div>
                    <div id="quizContainer" class="mt-6 p-4 bg-pink-50 rounded-xl"></div>
                </div>

                <div id="feedTab" class="tab-content" style="display:none;">
                    <p class="mb-4 text-gray-600">Discover a new trending slang word or idiom every day, pulled from the heart of Korean internet culture.</p>
                    <button onclick="getDailySlang()" class="px-6 py-3 bg-pink-400 text-white font-semibold rounded-full hover:bg-pink-500 transition shadow-md">Get Today's Slang</button>
                    <div id="feedLoader" class="loader hidden-loader"></div>
                    <div id="dailyFeed" class="mt-6 p-4 bg-pink-50 rounded-xl"></div>
                </div>

                <div id="chatbotTab" class="tab-content" style="display:none;">
                    <p class="mb-4 text-gray-600">Practice your slang! Chat with a bot that mimics different Korean personas.</p>
                    <div class="mb-4">
                        <span class="font-semibold mr-3">Choose a persona:</span>
                        <div class="inline-flex rounded-md shadow-sm" role="group">
                            <input type="radio" name="persona" id="teen" value="teen" class="hidden peer/teen" checked>
                            <label for="teen" class="px-4 py-2 text-sm font-medium text-gray-900 bg-white border border-gray-200 rounded-l-lg cursor-pointer hover:bg-gray-100 peer-checked/teen:bg-pink-400 peer-checked/teen:text-white peer-checked/teen:border-pink-500">Teen</label>
                            
                            <input type="radio" name="persona" id="lover" value="lover" class="hidden peer/lover">
                            <label for="lover" class="px-4 py-2 text-sm font-medium text-gray-900 bg-white border-t border-b border-gray-200 cursor-pointer hover:bg-gray-100 peer-checked/lover:bg-pink-400 peer-checked/lover:text-white peer-checked/lover:border-pink-500">Lover</label>

                            <input type="radio" name="persona" id="coworker" value="coworker" class="hidden peer/coworker">
                            <label for="coworker" class="px-4 py-2 text-sm font-medium text-gray-900 bg-white border-t border-b border-gray-200 cursor-pointer hover:bg-gray-100 peer-checked/coworker:bg-pink-400 peer-checked/coworker:text-white peer-checked/coworker:border-pink-500">Coworker</label>

                            <input type="radio" name="persona" id="busan" value="busan" class="hidden peer/busan">
                            <label for="busan" class="px-4 py-2 text-sm font-medium text-gray-900 bg-white border-t border-b border-gray-200 cursor-pointer hover:bg-gray-100 peer-checked/busan:bg-pink-400 peer-checked/busan:text-white peer-checked/busan:border-pink-500">Busan Satoori</label>
                            
                            <input type="radio" name="persona" id="business" value="business" class="hidden peer/business">
                            <label for="business" class="px-4 py-2 text-sm font-medium text-gray-900 bg-white border-t border-b border-gray-200 cursor-pointer hover:bg-gray-100 peer-checked/business:bg-pink-400 peer-checked/business:text-white peer-checked/business:border-pink-500">Formal/Business</label>

                            <input type="radio" name="persona" id="other" value="other" class="hidden peer/other">
                            <label for="other" class="px-4 py-2 text-sm font-medium text-gray-900 bg-white border border-gray-200 rounded-r-lg cursor-pointer hover:bg-gray-100 peer-checked/other:bg-pink-400 peer-checked/other:text-white peer-checked/other:border-pink-500">Other</label>
                        </div>
                    </div>
                    <div id="otherPersonaContainer" class="mt-4 hidden">
                        <label for="otherPersonaInput" class="block text-sm font-medium text-gray-700 mb-1">Describe the persona you want to chat with:</label>
                        <input type="text" id="otherPersonaInput" class="w-full p-3 border border-gray-200 rounded-xl focus:ring-2 focus:ring-pink-300 focus:border-pink-300 transition" placeholder="e.g., A wise old grandfather, a sassy barista...">
                    </div>
                    <div id="chatBox" class="chat-box h-80 overflow-y-auto p-4 bg-pink-50 rounded-xl mb-4 border"></div>
                    <div class="flex">
                        <input type="text" id="chatInput" class="w-full p-3 border border-gray-200 rounded-l-full focus:ring-2 focus:ring-pink-300 focus:border-pink-300 transition" placeholder="Type your message...">
                        <button onclick="sendChatMessage()" class="px-6 py-3 bg-pink-400 text-white font-semibold rounded-r-full hover:bg-pink-500 transition">Send</button>
                    </div>
                </div>
            </div>
        </main>
        
        <div id="messageModal" class="fixed top-5 right-5 bg-red-500 text-white py-2 px-4 rounded-lg shadow-lg transition-opacity duration-300 opacity-0">
            <p id="messageText"></p>
        </div>

        <div id="imageModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center p-4 z-50">
            <div class="bg-white rounded-2xl shadow-lg p-6 max-w-3xl w-full">
                <h3 class="text-xl font-bold mb-4">Adjust Box to Select Text</h3>
                <p class="mb-4 text-gray-600">Move and resize the box to cover the text you want to recognize.</p>
                <div id="imagePreviewContainer">
                    <img id="imagePreview" class="max-w-full max-h-full" />
                    <div id="resizableBox">
                        <div class="resize-handle nw"></div>
                        <div class="resize-handle ne"></div>
                        <div class="resize-handle sw"></div>
                        <div class="resize-handle se"></div>
                    </div>
                </div>
                <div class="mt-4 flex justify-end space-x-3">
                    <button onclick="closeImageModal()" class="px-5 py-2 bg-gray-200 text-gray-800 rounded-full hover:bg-gray-300 transition">Cancel</button>
                    <button onclick="runOcrOnSelection()" class="px-5 py-2 bg-pink-400 text-white rounded-full hover:bg-pink-500 transition">Extract Text</button>
                </div>
            </div>
        </div>

    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, collection, addDoc, getDocs, onSnapshot, doc, updateDoc, increment, query, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        
        // --- CONFIGURATION ---
        const GEMINI_API_KEY = "AIzaSyA_PgKWTcBmzFuYdjKAUojtzlD4nZng-EY"; // User-provided Gemini API Key
        const GEMINI_MODEL = "gemini-2.0-flash"; 
        
        // Firebase configuration from environment
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : { apiKey: "YOUR_FALLBACK_API_KEY", authDomain: "...", projectId: "..." };
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'k-slang-decoder';

        // --- INITIALIZATION ---
        let db, auth, userId;
        let chatHistory = [];
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);

        // --- AUTHENTICATION ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                console.log("User authenticated with UID:", userId);
                listenForPhrases();
            } else {
                console.log("No user signed in. Signing in anonymously...");
                try {
                     if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                     } else {
                        await signInAnonymously(auth);
                     }
                } catch (error) {
                    console.error("Anonymous sign-in failed:", error);
                    showMessage("Could not connect to the community features.");
                }
            }
        });

        // --- GLOBAL HELPER FUNCTIONS ---
        function showLoader(loaderId) { document.getElementById(loaderId).style.display = 'block'; }
        function hideLoader(loaderId) { document.getElementById(loaderId).style.display = 'none'; }
        
        function showMessage(message, isError = true) {
            const modal = document.getElementById('messageModal');
            const text = document.getElementById('messageText');
            text.textContent = message;
            modal.className = `fixed top-5 right-5 text-white py-2 px-4 rounded-lg shadow-lg transition-opacity duration-300 opacity-100 ${isError ? 'bg-red-500' : 'bg-green-500'}`;
            setTimeout(() => {
                modal.style.opacity = '0';
            }, 3000);
        }

        // --- TAB SWITCHING LOGIC ---
        window.showTab = function(tabId) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.style.display = 'none');
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tabId + 'Tab').style.display = 'block';
            document.querySelector(`button[onclick="showTab('${tabId}')"]`).classList.add('active');
        }

        // --- API ERROR HANDLING ---
        async function handleApiError(response) {
            if (!response.ok) {
                let errorBody;
                try {
                    errorBody = await response.json();
                } catch (e) {
                    errorBody = null;
                }
                const errorMessage = errorBody?.error?.message || response.statusText || `HTTP error ${response.status}`;
                throw new Error(`API error: ${errorMessage}`);
            }
            return response.json();
        }


        // --- FEATURE 1: DECODER & OCR ---
        window.analyzePhrase = async function() {
            const text = document.getElementById('koreanInput').value.trim();
            const context = document.getElementById('extraContext').value.trim();
            if (!text) {
                showMessage("Please enter a Korean phrase to decode.");
                return;
            }

            const structureBox = document.getElementById('structureResult');
            const explanationBox = document.getElementById('explanationResult');
            const listenBtnContainer = document.getElementById('listenBtnContainer');
            structureBox.innerHTML = '';
            explanationBox.innerHTML = '';
            listenBtnContainer.innerHTML = ''; // Clear previous listen button
            showLoader('decoderLoader');

            // UPDATED: Prompt with formatting instructions
            const prompt = `You are an expert Korean language tutor specializing in modern, trending slang used by young people on social media (TikTok, Twitter, Instagram). A user has provided a Korean phrase. Your task is to provide a two-part response.

**Korean Phrase:** "${text}"
**Context:** "${context || 'No context provided.'}"

**PART 1: JSON Data**
First, provide ONLY a valid JSON array of objects breaking down the phrase into its core components. Each object must have a "component" key (e.g., "Subject", "Adverb", "Object", "Verb") and a "word" key.
Example format: [{"component": "Adverb", "word": "완전"}, {"component": "Verb", "word": "찢었다"}]

**PART 2: Markdown Explanation**
On a new line, write the exact separator: "---BREAKDOWN---"
After the separator, provide a comprehensive analysis of the phrase in Markdown format. Do NOT include the sentence structure breakdown again here. Start directly with the translations. Include these sections:
### Literal & Natural Translation
- **Literal:** ...
- **Natural:** ...
### Slang & Idiom Deep Dive
- Explain the slang's meaning, nuance, and how it's used in online contexts. Crucially, ensure there is a blank line (an extra newline) before each new paragraph to create clear visual spacing.
- After the explanation, write "**Here are some example sentences:**" and then provide multiple, realistic example sentences.
### Grammar & Pronunciation
- ...`;

            try {
                const geminiResponse = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const geminiData = await handleApiError(geminiResponse);
                
                const geminiText = geminiData.candidates[0].content.parts[0].text;
                const parts = geminiText.split('---BREAKDOWN---');

                const listenButton = document.createElement('button');
                listenButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" /></svg> Listen`;
                listenButton.className = 'flex items-center px-4 py-2 bg-green-400 text-white font-semibold rounded-full hover:bg-green-500 transition shadow-md';
                listenButton.onclick = () => speakText(text);
                listenBtnContainer.appendChild(listenButton);

                if (parts.length < 2) {
                    console.warn("Model did not return the expected separator. Displaying raw output.");
                    explanationBox.innerHTML = marked.parse(geminiText);
                    structureBox.innerHTML = '';
                } else {
                    const jsonRegex = /```json\s*([\s\S]*?)\s*```/;
                    const match = parts[0].match(jsonRegex);
                    const structureJSON = match ? match[1].trim() : parts[0].trim();
                    const explanationMarkdown = parts[1].trim();

                    try {
                        const structureData = JSON.parse(structureJSON);
                        structureBox.innerHTML = '<h3 class="w-full text-lg font-semibold mb-2 text-gray-700">Sentence Structure</h3>';
                        structureData.forEach(item => {
                            const box = document.createElement('div');
                            box.className = 'text-center p-3 bg-fuchsia-100 rounded-lg shadow-sm';
                            box.innerHTML = `<div class="text-sm font-semibold text-fuchsia-800">${item.component}</div><div class="text-lg text-fuchsia-900">${item.word}</div>`;
                            structureBox.appendChild(box);
                        });
                    } catch (e) {
                        console.error("Failed to parse JSON structure:", e, "Raw JSON:", structureJSON);
                        structureBox.innerHTML = '<p class="text-red-500">Could not parse sentence structure.</p>';
                        explanationBox.innerHTML = marked.parse(explanationMarkdown);
                    }

                    explanationBox.innerHTML = marked.parse(explanationMarkdown);
                }

            } catch (error) {
                console.error("Analysis Error:", error);
                explanationBox.innerHTML = 'Error: ' + error.message;
                showMessage("Failed to analyze the phrase. Please check the console for details.");
            } finally {
                hideLoader('decoderLoader');
            }
        }

        function speakText(text) {
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'ko-KR';
                utterance.rate = 0.9;
                window.speechSynthesis.speak(utterance);
            } else {
                showMessage("Sorry, your browser does not support text-to-speech.");
            }
        }

        window.handleImageUpload = function(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const preview = document.getElementById('imagePreview');
                const modal = document.getElementById('imageModal');
                preview.src = e.target.result;
                preview.onload = () => {
                   setupResizableBox(preview);
                   modal.style.display = 'flex';
                }
            };
            reader.readAsDataURL(file);
            event.target.value = ''; // Reset file input
        }

        function setupResizableBox(img) {
            const box = document.getElementById('resizableBox');
            const container = document.getElementById('imagePreviewContainer');
            
            // Set initial size and position
            box.style.left = '50px';
            box.style.top = '50px';
            box.style.width = '200px';
            box.style.height = '100px';

            let currentResizer;
            let isResizing = false;
            let isMoving = false;
            let lastMouseX = 0;
            let lastMouseY = 0;

            box.addEventListener('mousedown', (e) => {
                e.preventDefault();
                isMoving = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            document.addEventListener('mousemove', (e) => {
                if (isMoving) {
                    const dx = e.clientX - lastMouseX;
                    const dy = e.clientY - lastMouseY;
                    
                    let newLeft = box.offsetLeft + dx;
                    let newTop = box.offsetTop + dy;

                    // Constrain movement within the container
                    if (newLeft < 0) newLeft = 0;
                    if (newTop < 0) newTop = 0;
                    if (newLeft + box.offsetWidth > container.clientWidth) newLeft = container.clientWidth - box.offsetWidth;
                    if (newTop + box.offsetHeight > container.clientHeight) newTop = container.clientHeight - box.offsetHeight;

                    box.style.left = `${newLeft}px`;
                    box.style.top = `${newTop}px`;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                } else if (isResizing) {
                    const dx = e.clientX - lastMouseX;
                    const dy = e.clientY - lastMouseY;
                    
                    if (currentResizer.classList.contains('se')) {
                        box.style.width = `${box.offsetWidth + dx}px`;
                        box.style.height = `${box.offsetHeight + dy}px`;
                    } else if (currentResizer.classList.contains('sw')) {
                        box.style.left = `${box.offsetLeft + dx}px`;
                        box.style.width = `${box.offsetWidth - dx}px`;
                        box.style.height = `${box.offsetHeight + dy}px`;
                    } else if (currentResizer.classList.contains('ne')) {
                        box.style.top = `${box.offsetTop + dy}px`;
                        box.style.width = `${box.offsetWidth + dx}px`;
                        box.style.height = `${box.offsetHeight - dy}px`;
                    } else { // nw
                        box.style.left = `${box.offsetLeft + dx}px`;
                        box.style.top = `${box.offsetTop + dy}px`;
                        box.style.width = `${box.offsetWidth - dx}px`;
                        box.style.height = `${box.offsetHeight - dy}px`;
                    }
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });

            document.addEventListener('mouseup', () => {
                isMoving = false;
                isResizing = false;
            });

            const resizers = box.querySelectorAll('.resize-handle');
            resizers.forEach(resizer => {
                resizer.addEventListener('mousedown', (e) => {
                    e.stopPropagation(); // Prevent moving the box while resizing
                    isResizing = true;
                    currentResizer = e.target;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                });
            });
        }

        window.closeImageModal = function() {
            document.getElementById('imageModal').style.display = 'none';
        }

        window.runOcrOnSelection = async function() {
            const imgEl = document.getElementById('imagePreview');
            const box = document.getElementById('resizableBox');

            const scaleX = imgEl.naturalWidth / imgEl.clientWidth;
            const scaleY = imgEl.naturalHeight / imgEl.clientHeight;

            const selection = {
                left: box.offsetLeft * scaleX,
                top: box.offsetTop * scaleY,
                width: box.clientWidth * scaleX,
                height: box.clientHeight * scaleY
            };

            if (!imgEl.src || !selection.width) {
                showMessage("Please make sure the selection box has a size.");
                return;
            }

            const statusEl = document.getElementById('ocrStatus');
            statusEl.textContent = 'Recognizing selected text...';
            closeImageModal();
            showLoader('decoderLoader');

            try {
                const worker = await Tesseract.createWorker('kor');
                const { data: { text } } = await worker.recognize(imgEl.src, {
                    rectangle: selection
                });
                await worker.terminate();
                document.getElementById('koreanInput').value = text;
                statusEl.textContent = 'Text extracted from selection!';
            } catch (error) {
                console.error("OCR Error:", error);
                statusEl.textContent = 'Could not read text from selection.';
                showMessage("Error reading text from image.");
            } finally {
                hideLoader('decoderLoader');
            }
        }
        
        window.startVoiceRecognition = function() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                showMessage("Sorry, your browser does not support voice recognition.");
                return;
            }
            const recognition = new SpeechRecognition();
            recognition.lang = 'ko-KR';
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;

            const button = document.getElementById('voiceInputBtn');
            button.classList.add('bg-red-500');
            showMessage("Listening...", false);

            recognition.start();

            recognition.onresult = (event) => {
                const speechResult = event.results[0][0].transcript;
                document.getElementById('koreanInput').value = speechResult;
            };

            recognition.onspeechend = () => {
                recognition.stop();
                button.classList.remove('bg-red-500');
            };

            recognition.onerror = (event) => {
                showMessage(`Error occurred in recognition: ${event.error}`);
                button.classList.remove('bg-red-500');
            };
        }

        window.translateToKorean = async function() {
            const sourceText = document.getElementById('sourceText').value.trim();
            const sourceLang = document.getElementById('sourceLang').value;
            const context = document.getElementById('translationContext').value.trim();
            const resultBox = document.getElementById('translationResult');
            const listenBtnContainer = document.getElementById('translationListenBtnContainer');
            
            if (!sourceText) {
                showMessage("Please enter text to translate.");
                return;
            }
            
            resultBox.textContent = '';
            listenBtnContainer.innerHTML = '';
            showLoader('translatorLoader');

            const prompt = `You are an expert translator who creates natural-sounding Korean. A user wants to translate a phrase from ${sourceLang} to Korean. Your task is to provide a translation that a native Korean speaker would actually use, considering the given context. Avoid literal, awkward, or machine-like translations.

**Source Language:** ${sourceLang}
**Source Phrase:** "${sourceText}"
**Context for translation:** "${context || 'General conversation'}"

Provide ONLY the natural Korean translation, with no extra text or explanations.`;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const data = await handleApiError(response);
                
                if (data.candidates && data.candidates.length > 0) {
                    const translatedText = data.candidates[0].content.parts[0].text;
                    resultBox.textContent = translatedText;

                    const listenButton = document.createElement('button');
                    listenButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" /></svg> Listen`;
                    listenButton.className = 'flex items-center px-4 py-2 bg-green-400 text-white font-semibold rounded-full hover:bg-green-500 transition shadow-md mt-2';
                    listenButton.onclick = () => speakText(translatedText);
                    listenBtnContainer.appendChild(listenButton);

                } else {
                    throw new Error("Could not get a valid translation from the AI.");
                }

            } catch (error) {
                console.error("Translation Error:", error);
                resultBox.textContent = 'Error: ' + error.message;
                showMessage("Failed to get translation.");
            } finally {
                hideLoader('translatorLoader');
            }
        }

        // --- FEATURE 3: COMMUNITY BANK ---
        const phrasesCollectionRef = collection(db, "artifacts", appId, "public", "data", "phrases");

        window.submitPhrase = async function() {
            if (!userId) {
                showMessage("You must be signed in to submit a phrase.");
                return;
            }
            const text = document.getElementById('submissionText').value.trim();
            if (!text) {
                showMessage("Please enter a phrase to submit.");
                return;
            }

            try {
                await addDoc(phrasesCollectionRef, {
                    text: text,
                    submitterId: userId,
                    votes: 0,
                    createdAt: new Date()
                });
                document.getElementById('submissionText').value = '';
                // UPDATED: Added success message
                showMessage("Your phrase has been submitted!", false);
            } catch (error) {
                console.error("Error submitting phrase:", error);
                showMessage("Failed to submit phrase.");
            }
        }
        
        function listenForPhrases() {
            const feed = document.getElementById('communityFeed');
            showLoader('communityLoader');
            onSnapshot(phrasesCollectionRef, (snapshot) => {
                hideLoader('communityLoader');
                if (snapshot.empty) {
                    feed.innerHTML = '<p class="text-gray-500">No phrases submitted yet. Be the first!</p>';
                    return;
                }
                const phrases = [];
                snapshot.forEach(doc => phrases.push({ id: doc.id, ...doc.data() }));
                
                phrases.sort((a, b) => b.votes - a.votes);

                feed.innerHTML = '';
                phrases.forEach(phrase => {
                    const div = document.createElement('div');
                    div.className = 'p-4 border rounded-xl bg-gray-50 flex justify-between items-center';
                    div.innerHTML = `
                        <p class="text-gray-800">${phrase.text}</p>
                        <div class="flex items-center space-x-3">
                            <span class="font-bold text-pink-500">${phrase.votes}</span>
                            <button data-id="${phrase.id}" class="upvote-btn p-2 rounded-full bg-pink-100 hover:bg-pink-200 transition">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-pink-500" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z" clip-rule="evenodd" /></svg>
                            </button>
                        </div>
                    `;
                    feed.appendChild(div);
                });

                document.querySelectorAll('.upvote-btn').forEach(btn => {
                    btn.addEventListener('click', () => upvotePhrase(btn.dataset.id));
                });
            });
        }

        async function upvotePhrase(id) {
            if (!userId) {
                showMessage("You must be signed in to vote.");
                return;
            }
            const phraseRef = doc(db, "artifacts", appId, "public", "data", "phrases", id);
            try {
                await updateDoc(phraseRef, {
                    votes: increment(1)
                });
            } catch(error) {
                console.error("Error upvoting:", error);
                showMessage("Failed to cast vote.");
            }
        }

        // --- FEATURE 4: GAMIFIED QUIZ ---
        window.generateQuiz = async function() {
            const quizContainer = document.getElementById('quizContainer');
            quizContainer.innerHTML = '';
            showLoader('quizLoader');

            try {
                // UPDATED: Prompt for more variety
                const prompt = `You are a creative quiz master for Korean language learners, acting as a Korean slang expert.
                Your task is to generate a UNIQUE and VARIED multiple-choice question each time this prompt is called.

                1.  **Select a random Korean slang word or expression.** This can be anything from modern internet slang (e.g., 킹받네, 어쩔티비), common abbreviations (e.g., 별다줄), or popular idioms used in daily life. **DO NOT repeat common words like '인싸', '대박', or '꿀잼' over and over.**
                2.  **Create a clear question** asking for the meaning of that word.
                3.  **Provide four plausible options**, with only one being correct.
                4.  **Format the entire output as a single, valid JSON object** with no other text before or after it.

                The JSON structure MUST be:
                {
                  "question": "The question about the slang word's meaning.",
                  "options": ["Option A", "Option B", "Option C", "Correct Answer"],
                  "answer": "The text of the correct answer"
                }

                Example of a good, varied question: "In a text message, what does the abbreviation '갑분싸' (gapbunssa) usually imply?"`;

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: { responseMimeType: "application/json" }
                    })
                });

                const data = await handleApiError(response);

                if (data.candidates && data.candidates.length > 0 && data.candidates[0].content.parts.length > 0) {
                    const quizData = JSON.parse(data.candidates[0].content.parts[0].text);
                    quizContainer.innerHTML = `<p class="font-semibold mb-4">${quizData.question}</p>`;
                    const optionsDiv = document.createElement('div');
                    optionsDiv.className = 'grid grid-cols-1 md:grid-cols-2 gap-2';
                    quizData.options.forEach(option => {
                        const button = document.createElement('button');
                        button.className = 'p-3 bg-white border rounded-lg hover:bg-gray-100 transition text-left';
                        button.textContent = option;
                        button.onclick = () => {
                            optionsDiv.querySelectorAll('button').forEach(btn => btn.disabled = true);
                            if (option === quizData.answer) {
                                button.classList.add('bg-green-200', 'border-green-400');
                                showMessage("Correct!", false);
                            } else {
                                button.classList.add('bg-red-200', 'border-red-400');
                                showMessage(`Not quite! The answer was: ${quizData.answer}`);
                            }
                        };
                        optionsDiv.appendChild(button);
                    });
                    quizContainer.appendChild(optionsDiv);
                } else {
                    console.error("Invalid quiz response from Gemini API:", data);
                    throw new Error("Could not parse the quiz response from the AI.");
                }

            } catch (error) {
                console.error("Quiz Generation Error:", error);
                quizContainer.innerHTML = `<p class="text-red-500">Could not generate a quiz at this time. ${error.message}</p>`;
            } finally {
                hideLoader('quizLoader');
            }
        }

        // --- FEATURE 5: DAILY FEED ---
        window.getDailySlang = async function() {
            const feedContainer = document.getElementById('dailyFeed');
            feedContainer.innerHTML = '';
            showLoader('feedLoader');

            const prompt = `You are a Korean culture expert. Generate a "Slang of the Day" for a Korean language learner.
            Pick a currently popular or interesting slang word/idiom.
            
            Provide your response in Markdown with the following sections:
            - The slang word in a large heading.
            - Pronunciation (Romanized).
            - Meaning.
            - A few example sentences in Korean with English translations.`;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const data = await handleApiError(response);
                
                if (data.candidates && data.candidates.length > 0 && data.candidates[0].content.parts.length > 0) {
                    feedContainer.innerHTML = marked.parse(data.candidates[0].content.parts[0].text);
                } else {
                    console.error("Invalid daily feed response from Gemini API:", data);
                    throw new Error("Could not parse the response from the AI for the daily slang.");
                }
            } catch (error) {
                console.error("Daily Feed Error:", error);
                feedContainer.innerHTML = `<p class="text-red-500">Could not fetch today's slang. ${error.message}</p>`;
            } finally {
                hideLoader('feedLoader');
            }
        }

        // --- FEATURE 6: ROLEPLAY CHATBOT ---
        window.sendChatMessage = async function() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            if (!message) return;

            addMessageToChat('user', message);
            input.value = '';

            const persona = document.querySelector('input[name="persona"]:checked').value;
            let systemPrompt = "You are a helpful Korean tutor.";
            
            if (persona === 'other') {
                const customPersona = document.getElementById('otherPersonaInput').value.trim();
                if (customPersona) {
                    systemPrompt = customPersona;
                } else {
                    showMessage("Please describe the 'Other' persona before chatting.");
                    return; 
                }
            } else if (persona === 'teen') {
                systemPrompt = "You are a Korean teenager. You use a lot of modern slang, shortened words (줄임말), and friendly, informal language. Respond in Korean.";
            } else if (persona === 'lover') {
                systemPrompt = "You are speaking to your romantic partner in Korean. Use sweet, affectionate, and informal language (애정 표현, 반말).";
            } else if (persona === 'coworker') {
                systemPrompt = "You are speaking to a friendly colleague at a Korean company. Use polite but not overly stiff language (해요체), as you would with a coworker (동료).";
            } else if (persona === 'busan') {
                systemPrompt = "You are a friendly person from Busan, Korea. You speak with a natural Busan dialect (사투리). Keep your responses relatively easy for a learner to understand but include some dialect flavor. Respond in Korean.";
            } else if (persona === 'business') {
                systemPrompt = "You are a professional in a Korean office setting. You use formal, polite language (존댓말) appropriate for business communication. Respond in Korean.";
            }

            chatHistory.push({ role: "user", parts: [{ text: message }] });

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: chatHistory,
                        systemInstruction: { parts: [{ text: systemPrompt }] }
                    })
                });
                const data = await handleApiError(response);

                if (data.candidates && data.candidates.length > 0 && data.candidates[0].content.parts.length > 0) {
                    const botMessage = data.candidates[0].content.parts[0].text;
                    chatHistory.push({ role: "model", parts: [{ text: botMessage }] });
                    addMessageToChat('bot', botMessage);
                } else {
                    console.error("Invalid chat response from Gemini API:", data);
                    addMessageToChat('bot', 'Sorry, I had a problem understanding the response from the AI.');
                }

            } catch (error) {
                console.error("Chatbot Error:", error);
                addMessageToChat('bot', 'Sorry, I had a problem responding.');
            }
        }
        
        function addMessageToChat(sender, message) {
            const chatBox = document.getElementById('chatBox');
            const messageDiv = document.createElement('div');
            messageDiv.className = `p-3 rounded-xl max-w-xs md:max-w-md mb-2 ${sender === 'user' ? 'bg-pink-200 ml-auto' : 'bg-gray-100 mr-auto'}`;
            messageDiv.textContent = message;
            chatBox.appendChild(messageDiv);
            chatBox.scrollTop = chatBox.scrollHeight;
        }
        
        document.querySelectorAll('input[name="persona"]').forEach(radio => {
            radio.addEventListener('change', (event) => {
                const otherContainer = document.getElementById('otherPersonaContainer');
                if (event.target.value === 'other') {
                    otherContainer.style.display = 'block';
                } else {
                    otherContainer.style.display = 'none';
                }

                chatHistory = []; 
                const chatBox = document.getElementById('chatBox');
                chatBox.innerHTML = ''; 
                const selectedLabel = document.querySelector(`label[for="${event.target.id}"]`).textContent;
                addMessageToChat('bot', `Persona changed to: ${selectedLabel}. Let's start a new conversation!`);
            });
        });

        document.getElementById('chatInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendChatMessage();
            }
        });

    </script>
</body>
</html>
